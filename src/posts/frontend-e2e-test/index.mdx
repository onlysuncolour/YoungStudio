---
title: "前端E2E自动化测试方案"
date: "2024-04-17"
spoiler: "ing......又出现P0bug了，测试就不能测得更全面一些吗？！！"
---

## 背景

随着公司产品线的增加，主力产品分配到的测试越来越少，他们做回归测试的压力也越来越大，甚至都出现过几次 P0 bug。

## 技术选型
在了解了市面上各个E2E的前端库之后，最后选择了[微软的playwright](https://playwright.dev/)。  

### why

虽然各种E2E的库最后生成的case文件 *.spec.js 都差不多，playwright自身还支持无头浏览器录制，及可视化查看case运行情况。  

当然，在具体实践中，肯定是不能让测试同学也敲命令行打开playwright的无头浏览器录制case，也还是需要我们有相应的插件直接在浏览器上录制case。

## 前置工作-testid

录制case最首先遇到的问题就是，我们项目中使用了CSS-Module。这导致了我们项目在每次build时所有的className都会发生变化，这也是之前测试同学尝试录制e2e用例时遇到的最大的问题。

在playwright文档中，他们推荐使用在元素属性里的data-testid或testid作为元素的唯一标识。

这次既然E2E自动化测试平台项目是前端主动发起的，那给项目里所有元素都添加data-testid也是我们义不容辞的工作了。

#### testid规范

在项目中，添加testid的过程是一个递归过程。

具体来说就是先在page层定义一个常量，**pageTestid**。  
给遇到的每个子component都传入 **testid=\{\`\$\{pageTestid}--childComponent\`}**，  
然后再去子component的文件中，继续给子子component添加testid，就像**testid=\{testid && \`\$\{testid}--grandchildComponent\`}**，  
抑或是一些最后的操作元素，比如有click事件的元素、button元素、input元素等，就要加上**data-testid=\{testid && \`\$\{testid}--action-btn\`}**

一层层文件递归完成，就表示这个page下的testid添加完成了。

如果添加过程中，有遇到循环遍历渲染的部分，要记住，千万不要把数据的id等加到testid中，而是要把**index**放进去。

示例如下

```tsx
// myPage.tsx
const pageTestid = 'my-page'
export function MyPage() {
  return <div>
    <ChildComponent testid={`${pageTestid}--child-component`} />
    <input name="value" data-testid={`${pageTestid}--value=input`} />
  </duv>
}
```

```tsx
// child-component.tsx
export function ChildComonent({testid}) {
  const dataList = [{id: 357, value: 1}, {id: 958, value: 1}]
  return <div>
    <GrandchildComponent testid={testid && `${testid}--grand-child-component`} />
    {
      dataList.map(({id}, index) => (
        <Button
          data-testid={testid && `${testid}--data-btn-${index}`}
          key={id}
        >{id}</Button>
      ))
    }
  </div>
}
```

#### 组件库添加testid

组件库中添加testid是一个比较困难的事情，你没有办法直接去修改组件库的源代码以便加入data-testid。

对于antd来说，其组件本身是支持data-testid这个属性的，但是也是支持有限，很多都只是在外层简单的加上了data-testid，其内部元素其实根本没有关注到。

当然，对于其中的Button、Input等组件，其支持的data-testid已经够用了。

对于select、dropdown等，可以给每个具体渲染文本改写成** \<span data-testid\>\{text\}\</span\> **

对于我司来说，组件库是基于antd的二次封装，我们在一些必要的组件里加入了强制递归写入data-testid的逻辑。

代码类似如下

```tsx
function addUiTestId (className, testid, flag?){
  if (testid) {
    const elements: any = document.getElementsByClassName(className) || [];
    Array.from(elements)?.forEach((el, i) => {
      setAttributeRecursively(
        el,
        'data-testid',
        generateId,
        !flag ? `${testid}--${className}` : className, // flag 为true，表示className已经包括testid了
        0,
        `${i}`,
      );
    });
  }
};

function setAttributeRecursively(
  element,
  attrName,
  attrValueGenerator,
  testid,
  depth = 0,
  index = '',
) {
  // 为当前元素设置属性，attrValueGenerator是一个函数，用于生成属性值
  if (shouldAddTestid(element, attrName)) {
    element.setAttribute(attrName, attrValueGenerator(testid, depth, index));
  }

  // 遍历所有子元素并递归调用此函数
  Array.from(element.children).forEach((child, i) => {
    setAttributeRecursively(
      child,
      attrName,
      attrValueGenerator,
      testid,
      depth + 1,
      `${index}-${i}`,
    );
  });
}
export function Component ({testid}) {
  useEffect({
    setTimeout(() => {
      addUiTestId(`ui-component--${testid}`, testid, true);
    }, 400)
  }, [])
  useEffect({
    if (open) {
      setTimeout(() => {
        addUiTestId(`ui-component--${testid}--dropdown`, testid, true);
      }, 400)
    }
  }, [open])
  return <div className={testid && `ui-component--${testid}`}>
    <Select dropdownClassName={testid && `ui-component--${testid}--dropdown`} />
    ...
  </div>
}
```

#### 小结

testid 最后在页面上其实可以表达为 **PageTestid--child-component--ui-component--test-id**。  
其中可以从双-中找到具体是哪个组件文件。  

添加testid的工作其实很快，给一个成熟的项目添加完备的testid，大概要占用一个同学一个月？的时间，至少在我司是这样。

## 录制case

最开始的想法，是让测试同学电脑上也安装上playwright，运行命令行进行录制。  
之后进行了几番思考，以及后续的功能迭代，还是决定自行开发录制case插件。  
插件嘛，当然是选择使用chrome extension插件咯。  

#### 工作流
预期中插件的工作流程应该是与playwright相差不大的，比如： 
* 输入命令行启动playwright的浏览器 和 点击插件的录制按钮
* 在playwright浏览器上hover到元素会有高亮，显示元素信息 和 录制过程中在chrome浏览器中也有高亮等
* 点击之后playwright会记录点击元素 和 like that
* input输入之后会记录 和 like that
* 生成完整的js文件 和 like that

由上述可以得出来，在录制过程中，或者说是录制开始阶段，是需要在页面上插入一系列js的。  
并且，为了能够持续、直观的看到之前的操作记录，插件应该是保持一致打开的，或者在页面上有一个弹窗展示操作记录。  
最后还要有根据操作记录生成完整的js文件。

#### 插件
由上面工作流可以看到，插件的主体部分，只承载了插入页面js、插入弹窗的功能。当然，插件部分，也会有更多的功能，之后再讲。

为了功能的好实现，这边首先引入一个js文件，承载插件与页面之间的通信。这个js文件在插件运行时就直接插入进去。
```js
// background.js
// 插件启动，监听tabs激活就直接插入进去
chrome.tabs.onActivated.addListener(async function (activeInfo) {
  chrome.tabs.get(activeInfo.tabId, function (tab) {
    if (!tab.url.startsWith("chrome://")) {
      chrome.scripting.executeScript({
        target: { tabId: activeInfo.tabId },
        files: ["content.js"],
      });
    }
  });
});
// 
// 负责与content.js通信
chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) {
  if (message.action === 'xxx') {}
})
```

而在content.js中，就负责在页面插入js、弹窗，以及和插件进行通信。这边的content.js是直接运行在页面中，而非插件中。
```js
chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
	const { tag, action } = request;
	const ul = window.location.host;
	switch (action) {
		case 'startRecord':
			const element = document.getElementById('e2e-testing-extend-container');
			if (element) {
				return;
			}
      appendModal();
      addResScript();
			break;
  }
})

function appendModal() {
  const pickerDiv = document.createElement("div");
  pickerDiv.id = "e2e-testing-extend-container";
  document.body.appendChild(pickerDiv);
}

function addResScript() {
	let script = document.createElement('script');
	script.setAttribute('defer', 'defer');
	script.src = chrome.runtime.getURL('embedded/embedded_main.js');
	document.body.appendChild(script);
}
```

#### 操作捕捉


#### 展示操作记录


#### 生成js代码


#### 提交case


## 测试平台

#### case管理


#### case运行


#### 


## 更多场景
